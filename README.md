# 1Cotlin

1Cotlin programming language. Created and developed by subadminka & lphfs.

Минимальный язык для экспериментов на Windows x64. Компилируется в .exe собственным компилятором.
Синтаксис нарочно сделан неудобным.

## Возможности
- печать через `исп.команду.print(...)`
- переменные через `пусть` и присваивание
- условия `в таком случае` и `иначе.если`
- повторение `повторять.раз`
- числа, строки, логика
- списки и массивы
- старый синтаксис больше не поддерживается

## Пример

```1cotlin
пусть n = 5
исп.команду.print("привет")
повторять.раз n {
    исп.команду.print(n)
}

в таком случае n > 2 {
    исп.команду.print("много")
} иначе.если {
    исп.команду.print("мало")
}
```

Доп. пример с коллекциями: `examples\collections.1c`.

## Синтаксис

### Ключевые слова

`пусть`, `исп.команду.print(...)`, `в таком случае`, `иначе.если`, `повторять.раз`, `истина.ок`, `ложь.падение`, `и.также`, `или.иначе`, `не.а`

Оператор "не равно": `=/=`

### Переменные

```1cotlin
пусть x = 10
x = x + 5
```

### Числа и логика

```1cotlin
пусть a = 3
пусть b = 7
исп.команду.print(a * b)
исп.команду.print(a =/= b)
исп.команду.print(не.а ложь.падение)
```

### Условия

```1cotlin
пусть n = 2
в таком случае n == 2 {
    исп.команду.print("ok")
} иначе.если {
    исп.команду.print("no")
}
```

### Повторение

```1cotlin
повторять.раз 3 {
    исп.команду.print("again")
}
```

### Строки

```1cotlin
исп.команду.print("hello")
```

Строки используются только в print. Переменным и арифметике доступны только числа и логика.

### Списки и массивы

Списки и массивы хранят только числа. Список можно заполнять через `впихни.в.лист`.

```1cotlin
пусть xs = создать.лист.цифр(4)
впихни.в.лист(xs, 10)
впихни.в.лист(xs, 20)
исп.команду.print(сколько.внутри(xs))
исп.команду.print(дай.по.индексу(xs, 1))
сунь.по.индексу(xs, 1, 33)
исп.команду.print(дай.по.индексу(xs, 1))

пусть ys = создать.массив.цифр(3)
сунь.по.индексу(ys, 0, 7)
сунь.по.индексу(ys, 1, 8)
сунь.по.индексу(ys, 2, 9)
исп.команду.print(сколько.внутри(ys))
```

### Встроенные функции

`создать.лист.цифр([cap])`, `создать.массив.цифр(n)`, `сколько.внутри(x)`, `дай.по.индексу(list, i)`, `сунь.по.индексу(list, i, v)`, `впихни.в.лист(list, v)`, `достань.последний(list)`, `диапазон.от.0.до(n)`

## Требования
- Windows x64
- Visual Studio 2022 (MSVC) или MinGW (gcc)

## Сборка компилятора

```powershell
cl /Fe:1cotlinc.exe main.c lexer.c parser.c sema.c codegen.c pe.c util.c
```

Если нет MSVC:

```powershell
gcc -O2 -o 1cotlinc.exe main.c lexer.c parser.c sema.c codegen.c pe.c util.c
```

## Компиляция .1c в .exe

```powershell
.\1cotlinc.exe examples\hello.1c
```

Выходной файл по умолчанию рядом с исходником: `examples\hello.exe`.
Можно задать имя вручную:

```powershell
.\1cotlinc.exe examples\hello.1c myprog.exe
```

## Запуск

```powershell
.\examples\hello.exe
```

## Заметки
- Файлы .1c можно сохранять в UTF-8 или UTF-16LE, компилятор читает оба.
- `исп.команду.print` печатает значение и перевод строки.
